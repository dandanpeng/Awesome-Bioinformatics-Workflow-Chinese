---
title: 校正单细胞 RNA 测序数据中的批次效应
author: 
- name: Aaron T. L. Lun
  affiliation: Cancer Research UK Cambridge Institute, Li Ka Shing Centre, Robinson Way, Cambridge CB2 0RE, United Kingdom
- name: Michael D. Morgan
  affiliation: Wellcome Trust Sanger Institute, Wellcome Genome Campus, Hinxton, Cambridge CB10 1SA, United Kingdom
date: "`r Sys.Date()`"
vignette: >
  %\VignetteIndexEntry{05. Correcting batch effects}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}    
output: 
  BiocStyle::html_document:
    titlecaps: false
    toc_float: true
bibliography: ref.bib
---

```{r style, echo=FALSE, results='hide', message=FALSE, cache=FALSE}
library(BiocStyle)
library(knitr)
opts_chunk$set(error=FALSE, message=FALSE, warning=FALSE, cache=TRUE)
opts_chunk$set(fig.asp=1)
```

# 导语

受到流程限制，大型单细胞 RNA 测序（scRNA-seq）项目通常需要产生多个批次数据。
但在处理不同批次数据时常常会有不可控差异，例如：操作人员更换，试剂质量差异。
这导致在不同批次中观察到细胞表达量的系统差异，我们称其为「批次效应」。
批次效应很难处理，它是导致数据异质性的主要因素，它掩饰了相关的生物差异，复杂化结果的解释。

通过计算校正这些效应对于去除批次间的差异非常重要，这样就可以结合多个批次的数据以进行下游分析。
已有方法例如 `removeBatchEffect()` [@rirchie2015limma] 假设细胞群体构成是已知的或在不同批次间一样。
此工作流程基于互近邻（MNN)，采用另一策略进行批次校正 [@haghverdi2018batch]。
MNN 方法不依赖批次间预定义的或相同的群体构成，它仅仅要求批次间拥有共同群体子集。
这里通过两项独立研究中的人类胰腺单细胞 RNA 测序数据集来演示 MNN。

# 处理不同数据集

## CEL-seq, GSE81076

### 加载数据

这个数据由 @run2016denovo 用 CEL-seq 实验方案通过单一分子识别（UMI）和 ERCC spike-ins 产生。
计数表格通过上面的登陆号 从 NCBI Gene Expression Omnibus 获取。

```{r}
library(BiocFileCache)
bfc <- BiocFileCache("raw_data", ask = FALSE)
grun.fname <- bfcrpath(bfc, file.path("ftp://ftp.ncbi.nlm.nih.gov/geo/series",
    "GSE81nnn/GSE81076/suppl/GSE81076%5FD2%5F3%5F7%5F10%5F17%2Etxt%2Egz"))
```

首先将数据读入内存。

```{r}
gse81076.df <- read.table(grun.fname, sep='\t', 
    header=TRUE, stringsAsFactors=FALSE, row.names=1)
dim(gse81076.df)
head(rownames(gse81076.df))
head(colnames(gse81076.df))
```

遗憾的是这个文件中的数据和元数据混合在一起。
所以我们需要从列名中手动提取元数据。

```{r}
donor.names <- sub("^(D[0-9]+).*", "\\1", colnames(gse81076.df))
table(donor.names)
plate.id <- sub("^D[0-9]+(.*)_.*", "\\1", colnames(gse81076.df))
table(plate.id)
```

这个数据集另一个恼人的点在于它提供的是 gene symbols 而不是 Ensembl 这样稳定的标识符。
稳定的标识符比较可取，因为它们使得数据集间交叉参考基因标识符时更可靠^[此工作使用的两个数据集来源相同，至少他们一致使用gene symbols。从技术角度上我们可以略过转换步骤。尽管如此，我们还是需要演示一下这一步，以免你遇到更复杂的数据源（例如：Ensembl 和 gene symbols 混合，或者多个同义的 gene symbols 混合）。]。
我们将所有行名转换为 Ensembl 标识符，移除了'NA'或重复条目（除 spike-in 转录本之外）。

```{r}
gene.symb <- gsub("__chr.*$", "", rownames(gse81076.df))
is.spike <- grepl("^ERCC-", gene.symb)
table(is.spike)

library(org.Hs.eg.db)
gene.ids <- mapIds(org.Hs.eg.db, keys=gene.symb, keytype="SYMBOL", column="ENSEMBL")
gene.ids[is.spike] <- gene.symb[is.spike]

keep <- !is.na(gene.ids) & !duplicated(gene.ids)
gse81076.df <- gse81076.df[keep,]
rownames(gse81076.df) <- gene.ids[keep]
summary(keep)
```

创建 `SingleCellExperiment` 对象储存计数和元数据。
这会降低后续分析中出现记录错误的风险。
注意我们重新定义了 spike-in 行，因为之前的索引可能会在取子集后改变。

```{r}
library(SingleCellExperiment)
sce.gse81076 <- SingleCellExperiment(list(counts=as.matrix(gse81076.df)),
	colData=DataFrame(Donor=donor.names, Plate=plate.id),
	rowData=DataFrame(Symbol=gene.symb[keep]))
isSpike(sce.gse81076, "ERCC") <- grepl("^ERCC-", rownames(gse81076.df)) 
sce.gse81076  
```

### 质量控制和归一化

对每个细胞计算质量控制（QC）指标 [@mccarthy2017scater]，识别出文库较小，表达基因少或 ERCC 含量高的细胞。

```{r}
library(scater)
sce.gse81076 <- calculateQCMetrics(sce.gse81076, compact=TRUE)
QC <- sce.gse81076$scater_qc
low.lib <- isOutlier(QC$all$log10_total_counts, type="lower", nmad=3)
low.genes <- isOutlier(QC$all$log10_total_features_by_counts, type="lower", nmad=3)
high.spike <- isOutlier(QC$feature_control_ERCC$pct_counts, type="higher", nmad=3)
data.frame(LowLib=sum(low.lib), LowNgenes=sum(low.genes), 
	HighSpike=sum(high.spike, na.rm=TRUE))
```

质控指标处于极端值的细胞被认为是低质量细胞，需要移除。
更完整的分析方法是预先检查质控指标的分布，简洁起见，我们跳过这一步。

```{r}
discard <- low.lib | low.genes | high.spike
sce.gse81076 <- sce.gse81076[,!discard]
summary(discard)
```

使用去卷积方法对内源基因计算量化因子 [@lun2016pooling]。
这一步经 `quickCluster()` 通过预先聚类完成，避免差异很大的细胞池化在一起。

```{r}
library(scran)
library(BiocSingular)
set.seed(1000) # for irlba. 
clusters <- quickCluster(sce.gse81076, use.ranks=FALSE, BSPARAM=IrlbaParam())
table(clusters)
sce.gse81076 <- computeSumFactors(sce.gse81076, min.mean=0.1, clusters=clusters)
summary(sizeFactors(sce.gse81076))
```

同样对 spike-in 转录本计算量化因子 [@lun2017assessing]。
设置 `general.use=FALSE` 是为了确保 spike-in 量化因子只适用于 spike-in 转录本。 

```{r}
sce.gse81076 <- computeSpikeFactors(sce.gse81076, general.use=FALSE)
summary(sizeFactors(sce.gse81076, "ERCC"))
```

为下游分析计算归一化对数表达量。

```{r}
sce.gse81076 <- normalize(sce.gse81076)
```

### 识别高度变异基因

通过 `trendVar()` 和 `decomposeVar()`，利用 spike-in 转录本的差异来模拟技术噪音，识别出高度变异基因（HVGs)。
设置 `block=` 以确保不同平板间或供者间无意义的区别不会加大差异。
图 \@ref(fig:var-gse81076) 中拟合趋势的偏差很小是因为趋势与 spike-ins 的区组差异稳健拟合，
而区组间的差异被平均掉了，对异常值不稳健。

```{r var-gse81076, fig.cap="Variance of normalized log-expression values for each gene in the GSE81076 dataset, plotted against the mean log-expression. The blue line represents the mean-dependent trend fitted to the variances of the spike-in transcripts (red)."}
block <- paste0(sce.gse81076$Plate, "_", sce.gse81076$Donor)
fit <- trendVar(sce.gse81076, block=block, parametric=TRUE) 
dec <- decomposeVar(sce.gse81076, fit)

plot(dec$mean, dec$total, xlab="Mean log-expression", 
	ylab="Variance of log-expression", pch=16)
is.spike <- isSpike(sce.gse81076)
points(dec$mean[is.spike], dec$total[is.spike], col="red", pch=16)
curve(fit$trend(x), col="dodgerblue", add=TRUE)
```

根据生物元件对基因进行降序排序，反映出一些常见的可疑对象比如胰岛素和胰高血糖素。
这些信息在运行 `mnnCorrect()` 前做特征选择时会用到。

```{r}
dec.gse81076 <- dec
dec.gse81076$Symbol <- rowData(sce.gse81076)$Symbol
dec.gse81076 <- dec.gse81076[order(dec.gse81076$bio, decreasing=TRUE),]
head(dec.gse81076)
```

```{r, echo=FALSE, results="hide"}
rm(gse81076.df)
gc()
```

## CEL-seq2, GSE85241

### 加载数据

这个数据是由  @muraro2016singlecell 用 CEL-seq2 实验方案通过单一分子识别（UMI）和 ERCC spike-ins 产生。
计数表格通过上面的登陆号 从 NCBI Gene Expression Omnibus 获取。

```{r}
muraro.fname <- bfcrpath(bfc, file.path("ftp://ftp.ncbi.nlm.nih.gov/geo/series",
    "GSE85nnn/GSE85241/suppl",
    "GSE85241%5Fcellsystems%5Fdataset%5F4donors%5Fupdated%2Ecsv%2Egz"))
```

首先将数据读入内存。

```{r}
gse85241.df <- read.table(muraro.fname, sep='\t', 
    header=TRUE, row.names=1, stringsAsFactors=FALSE)
dim(gse85241.df)
head(rownames(gse85241.df))
head(colnames(gse85241.df))
```

从列名中提取元数据。

```{r}
donor.names <- sub("^(D[0-9]+).*", "\\1", colnames(gse85241.df))
table(donor.names)
plate.id <- sub("^D[0-9]+\\.([0-9]+)_.*", "\\1", colnames(gse85241.df))
table(plate.id)
```

又遇到了使用 gene symbols 而非 Ensembl 或 Entrez 标识符的情况。
将所有行名转换为 Ensembl 标识符，移除'NA'或重复条目（除 spike-in 转录本之外）。

```{r}
gene.symb <- gsub("__chr.*$", "", rownames(gse85241.df))
is.spike <- grepl("^ERCC-", gene.symb)
table(is.spike)

library(org.Hs.eg.db)
gene.ids <- mapIds(org.Hs.eg.db, keys=gene.symb, keytype="SYMBOL", column="ENSEMBL")
gene.ids[is.spike] <- gene.symb[is.spike]

keep <- !is.na(gene.ids) & !duplicated(gene.ids)
gse85241.df <- gse85241.df[keep,]
rownames(gse85241.df) <- gene.ids[keep]
summary(keep)
```

创建 `SingleCellExperiment` 对象储存计数和元数据。

```{r}
sce.gse85241 <- SingleCellExperiment(list(counts=as.matrix(gse85241.df)),
	colData=DataFrame(Donor=donor.names, Plate=plate.id),
	rowData=DataFrame(Symbol=gene.symb[keep]))
isSpike(sce.gse85241, "ERCC") <- grepl("^ERCC-", rownames(gse85241.df)) 
sce.gse85241  
```

### 质量控制和归一化

对每个细胞计算质量控制（QC）指标 [@mccarthy2017scater]，识别出文库较小，表达基因少或 ERCC 含量高的细胞。

```{r}
sce.gse85241 <- calculateQCMetrics(sce.gse85241, compact=TRUE)
QC <- sce.gse85241$scater_qc
low.lib <- isOutlier(QC$all$log10_total_counts, type="lower", nmad=3)
low.genes <- isOutlier(QC$all$log10_total_features_by_counts, type="lower", nmad=3)
high.spike <- isOutlier(QC$feature_control_ERCC$pct_counts, type="higher", nmad=3)
data.frame(LowLib=sum(low.lib), LowNgenes=sum(low.genes), 
	HighSpike=sum(high.spike, na.rm=TRUE))
```

质控指标处于极端值的细胞被认为是低质量细胞，需要移除。

```{r}
discard <- low.lib | low.genes | high.spike
sce.gse85241 <- sce.gse85241[,!discard]
summary(discard)
```

对内源基因和 spike-in 转录本计算量化因子, 计算归一化对数表达量。

```{r}
set.seed(1000)
clusters <- quickCluster(sce.gse85241, use.ranks=FALSE, BSPARAM=IrlbaParam())
table(clusters)
sce.gse85241 <- computeSumFactors(sce.gse85241, min.mean=0.1, clusters=clusters)
summary(sizeFactors(sce.gse85241))
sce.gse85241 <- computeSpikeFactors(sce.gse85241, general.use=FALSE)
summary(sizeFactors(sce.gse85241, "ERCC"))
sce.gse85241 <- normalize(sce.gse85241)
```

### 识别高度变异基因

同上，拟合 spike-in 差异，从而模拟每个基因的技术噪音 (图 \@ref(fig:var-gse85241))。
设置 `block=` 以确保不同平板或供者间无意义的区别不会加大差异。

```{r var-gse85241, fig.cap="Variance of normalized log-expression values for each gene in the GSE85241 dataset, plotted against the mean log-expression. The blue line represents the mean-dependent trend fitted to the variances of the spike-in transcripts (red)."}
block <- paste0(sce.gse85241$Plate, "_", sce.gse85241$Donor)
fit <- trendVar(sce.gse85241, block=block, parametric=TRUE) 
dec <- decomposeVar(sce.gse85241, fit)
plot(dec$mean, dec$total, xlab="Mean log-expression", 
	ylab="Variance of log-expression", pch=16)
is.spike <- isSpike(sce.gse85241)
points(dec$mean[is.spike], dec$total[is.spike], col="red", pch=16)
curve(fit$trend(x), col="dodgerblue", add=TRUE)
```

同上，根据生物元件对基因进行降序排序。

```{r}
dec.gse85241 <- dec
dec.gse85241$Symbol <- rowData(sce.gse85241)$Symbol
dec.gse85241 <- dec.gse85241[order(dec.gse85241$bio, decreasing=TRUE),]
head(dec.gse85241)
```

```{r, echo=FALSE, results="hide"}
rm(gse85241.df)
gc()
```

## 关于额外批次的评论

在 @haghverdi2018batch 中，我们对四个不同的胰腺单细胞 RNA 测序数据集进行了批次校正。
简洁起见，我们将只考虑用 CEL-seq(2) 产生的两个批次，忽略用 Smart-seq2 产生的另两个批次 [@segerstolpe2016singlecell;@lawlor2017singlecell]。
大家可能会觉得对同一种技术产生的数据进行批次校正最为简单，
因为干扰生物结构的系统差异更少，
但通常对不同技术产生的多批次数据进行 MNN 校正能得到较好结果。

还需要指出，上面提到由 CEL-seq(2) 产生的两个批次来自多个供者。
因为他们自身的因素，每个供者被当作一个独立的批次，
反映出将人类作为研究对象时由于基因型，年龄，性别或其他不可控因素带来的（可能无意义）生物差异。
简洁起见，我们忽略每项研究中的供者效应，只考虑消除两项研究间的批次效应。
但我们是可以先在同批次内供者间，然后在不同批次间应用 MNN 校正 - 查看 `?fastMNN` 获取更多细节。

# 批次间特征选择

为了得到一套用于批次校正的特征集合，我们计算了所有批次间的平均生物成分，
我们采用所有包含阳性生物成分的基因以确保所有有意义的生物差异被保留，这一操作等同于使用 `denoisePCA()`。
但是校正质量通常对技术噪音很敏感，所以做特征选择时要十分谨慎。
用户喜欢采用前 1000-5000 个平均元件最多的基因，或者用 `combineVar()` 获取联合 $p$-值来进行基因选择。

```{r}
universe <- intersect(rownames(dec.gse85241), rownames(dec.gse81076))
mean.bio <- (dec.gse85241[universe,"bio"] + dec.gse81076[universe,"bio"])/2
chosen <- universe[mean.bio > 0]
length(chosen)
```

我们还重新调整了每个批次以适应批次间测序深度的差异。
对 `SingleCellExperiment` 对象间覆盖度的系统差异调整量化因子后，用 `multiBatchNorm()` 函数重新计算归一化对数表达量。
（之前计算的量化因子只是移除了同一批次 _内_ 细胞间的偏差。）
这样通过移除批次间某一方面技术差异提高了校正质量。

```{r}
rescaled <- batchelor::multiBatchNorm(
    sce.gse85241[universe,], 
    sce.gse81076[universe,]
)
rescaled.gse85241 <- rescaled[[1]]
rescaled.gse81076 <- rescaled[[2]]
```

**来自 Aaron 的评论：**

- 从技术上说，应该在调用 `multiBatchNorm()` _后_ 进行差异模拟和特征选择。
这样能够确保用于批次校正的差异元素是从同样的数值估计而来的。
实际上，这样操作结果没有什么不同，而且像上文中那样单独处理每个批次之后一步合并所有结果更为简单。
- `batchelor::` 前缀避免了 `multiBatchNorm()` 从`r Biocpkg("scran")` 迁移到  `r Biocpkg("batchelor")` 的歧义。
下个版本中就不必使用这个前缀了。

# 执行基于 MNN 的校正

在由选取特征定义的表达空间中，考虑批次 $A$ 中的细胞 $a$, 识别出批次 $B$ 中的细胞是 $a$ 的近邻。
对批次 $B$ 中的细胞 $b$ 重复该操作，识别出它的近邻在 $A$ 中。
互近邻是来自于不同批次中的细胞对，这些批次互为对方的近邻。
推理可得，MNN 对首先考虑来自相同生物状态的细胞，然后是批次效应作用 - 查看 @haghverdi2018batch 获取完整理论细节。
因此，可以用 MNN 对中细胞的差异来估计批次效应，减去这个差异可以得到批次校正值。

使用`chosen` 中的基因， 对三个批次应用 `fastMNN()` 函数以去除批次效应，
为减少计算工作中和技术中的噪音，所有细胞被投影到由前 `d` 个主成分定义的低维空间中，
之后在该低维空间中进行MNN识别和校正向量计算。
此函数返回了一个 `SingleCellExperiment` 对象，包含后续分析如聚类或可视化需要用到的低维校正值。

```{r}
set.seed(100) 
unc.gse81076 <- logcounts(rescaled.gse81076)[chosen,]
unc.gse85241 <- logcounts(rescaled.gse85241)[chosen,]

mnn.out <- batchelor::fastMNN(
    GSE81076=unc.gse81076, GSE85241=unc.gse85241,
    k=20, d=50, BSPARAM=IrlbaParam(deferred=TRUE)
)
mnn.out
```

`mnn.out` 中每一列对应某个批次中的一个细胞， 每一行对应 `chosen` 中的一个输入基因。
`reducedDims` 槽中的 `corrected` 矩阵包含所有细胞的低维校正坐标。

```{r}
dim(reducedDim(mnn.out, "corrected"))
```

列元数据中的 `batch` 域包含一个对象，说明了每个细胞的来源批次。

```{r}
# Using an Rle for pretty-printing of batch IDs
# (as all cells from the same batch are consecutive).
Rle(mnn.out$batch) 
```

高级用户可能会对 `pairs` 元数据域中 `DataFrame` 组成的列表感兴趣。
每个 `DataFrame` 描述了合并后每一批次识别出的MNN对。
这个信息可能会在检查已知细胞类型中识别的MNN对中用到，例如：确定细胞类型是否配对正确。

```{r}
metadata(mnn.out)$merge.info$pairs[[1]]
```

如上所述，为了简化工作流程，我们只用了两个批次。
但 MNN 方法不局限于两个批次，向 `fastMNN()` 中添加更多 `SingleCellExperiment` 对象即可添加更多批次。

**来自 Aaron 的评论:**

- 在定义 MNN 对时， `k=` 参数指定了近邻个数。
可以将其理解为每个批次中每种细胞类型或状态出现的最小频率。
  - 通过提高 MNN 对的个数可以提高校正的精确度。
    在识别正确的 MNN 对时，允许搜寻邻居时忽略批次内的生物差异，
    这也加强了对于「批次向量正交于生物子空间」这一假设的反驳 [@haghverdi2018batch]。
  - 但是，更高的 `k` 值意味着允许在不同类型细胞间形成错误的 MNN 对，这样就降低了准确性。
  因此我们建议从默认 `k` 值开始，确定不同批次中同类型细胞不会充分合并时再提高取值。
  这样要比从一个较大 `k` 值开始要好，因为判断错误的合并比判断不充分的合并要难。
- 当 `BSPARAM=IrlbaParam(deferred=TRUE)` 时, `fastMNN()` 使用 `r CRANpkg("irlba")` 包中的方法快速进行主成分分析。
当每一次运行之间差异极小时，就需要运行 `set.seed()` 获得可完全重复的结果。
`deferred=` 变量使 `fastMNN()` 为了速度提升牺牲一些精确度。

```{r, echo=FALSE, results="hide"}
gc()
```

# 检查校正效果

## 可视化

我们通过一些 _t_-SNE 图来检查批次校正。
图 \@ref(fig:tsne-batch) 表示在未校正数据中基于原始批次的细胞分离情况。
校正后，随着批次效应消除，可以观察到批次更好地混合在一起。
注意到 E-MTAB-5601 数据集仍然表现出一些分离，可能是因为另一批次来自 UMI 数据集。

```{r tsne-batch, fig.width=10, fig.asp=0.6, fig.cap="t-SNE plots of the pancreas datasets, before and after MNN correction. Each point represents a cell and is coloured by the batch of origin."}
# Adding uncorrected values.
sce <- mnn.out
assay(sce, "original") <- cbind(unc.gse81076, unc.gse85241)

# Using irlba to set up the t-SNE, for speed.
set.seed(100)
osce <- runPCA(sce, exprs_values="original", ntop=Inf, BSPARAM=IrlbaParam())
osce <- runTSNE(osce, use_dimred="PCA")
ot <- plotTSNE(osce, colour_by="batch") + ggtitle("Original")

# Corrected.
set.seed(100)
sce <- runTSNE(sce, use_dimred="corrected")
ct <- plotTSNE(sce, colour_by="batch") + ggtitle("Corrected")

multiplot(ot, ct, cols=2)
```

我们根据标志基因表达量给已知胰腺细胞类型上色，借此判断校正是否生物敏感。
同一类群细胞表达同样的标志基因（图 \@ref(fig:tsne-markers)), 说明校正依然维持了细胞类型分离。

```{r tsne-markers, fig.width=10, fig.height=10, fig.cap="t-SNE plots after MNN correction, where each point represents a cell and is coloured by its corrected expression of key marker genes for known cell types in the pancreas."}
# Replacing the row names for easier reference.
rowData(sce)$ENSEMBL <- rownames(sce)    
rowData(sce)$SYMBOL <- mapIds(org.Hs.eg.db, keytype="ENSEMBL", 
    keys=rownames(sce), column="SYMBOL")
rownames(sce) <- uniquifyFeatureNames(rownames(sce), rowData(sce)$SYMBOL)

ct.gcg <- plotTSNE(sce, by_exprs_values="reconstructed", colour_by="GCG") 
ct.ins <- plotTSNE(sce, by_exprs_values="reconstructed", colour_by="INS") 
ct.sst <- plotTSNE(sce, by_exprs_values="reconstructed", colour_by="SST") 
ct.ppy <- plotTSNE(sce, by_exprs_values="reconstructed", colour_by="PPY") 

multiplot(ct.gcg + ggtitle("Alpha cells"),
    ct.ins + ggtitle("Beta cells"),
    ct.sst + ggtitle("Delta cells"),
    ct.ppy + ggtitle("PP cells"),
    cols=2)
```

## 诊断

一个有用的诊断是每批次内差异在 MNN 校正中丢失的比例。
也就是说，每一次合并中关于平均校正向量正交时，批次内差异被移除。
元数据 `mnn.out` 中 `lost.var` 域返回这一结果，它包含一个矩阵，矩阵内是每一次合并步骤（行）中每一批次 （列）丢失的差异。

```{r}
metadata(mnn.out)$merge.info$lost.var
```

高比例差异丢失意味校正去除了真正的生物异质性。
违背「批次效应和生物子空间正交假设」时就会发生这种情况 [@haghverdi2018batch]。
这个例子中差异丢失比例很小，说明非正交性不是主要问题。

```{r, echo=FALSE, results="hide"}
gc()
```

# 控制合并顺序

## 手动指定

第一批次用于定义参考空间，其余批次校正都以此为基准，所以批次排序会对结果产生影响。
说明确一些就是第一批次被定义为参考批次，
第二批次根据参考批次进行校正，之后与其合并得到一个新参考批次；
像这样对排好序的所有批次操作，每一步会得到一个更大的参考批次。
使用合并参考确保在对后面批次进行 MNN 对识别时信息来自之前所有批次而不只是第一批次。

批次合并顺序可以通过 `fastMNN()` 中的参数 `auto.order=` 手动指定。
在下面的例子中，batch2 在 `auto.order=` 中排第一位，所以被当作参考。
如果有多于两个批次出现，第一个批次校正过第二个批次后得到新参考批次，以此类推。

```{r}
mnn.out2 <- batchelor::fastMNN(
    GSE81076=unc.gse81076, GSE85241=unc.gse85241,
    k=20, d=50, auto.order=c(2,1), BSPARAM=IrlbaParam(deferred=TRUE)
)
metadata(mnn.out2)$merge.order # batch 2 (GSE85241) is first in the order.
metadata(mnn.out2)$merge.info$pairs[[1]] # 'first' now refers to GSE85241.
```

使用 `auto.order=` 可以在不改变 `fastMNN()` 提供的批次顺序前提下改变合并顺序。
同样，输出批次（和细胞）顺序也不会被改变。
这样可以在不改变代码的同时很方便地尝试不同的合并顺序。

```{r}
Rle(mnn.out2$batch) # same as mnn.out$batch
```

如果有差异很大（从细胞组成角度）的批次出现，我们建议将最大，异质性最高的批次作为第一个。
这样确保校正过程中通过对比第一批次和其他批次时能够识别足够的 MNN 对。
相反，如果一开始对比的是两个没有共同群体的小批次，会导致找出错误的 MNN 对，合并也不正确。

```{r, echo=FALSE, results="hide"}
gc()
```

## 分层合并

### 动机

在更复杂的实验中，我们可能会事先得知某一些批次更为相似。
我们可能希望在合并那些具有不同细胞类型组成和/或基因表达的批次之前，先合并这些相似批次。
例如：

- 在根据条件合并之前，先合并那些在同一条件下来自重复实验的批次。
- 在根据技术合并之前，先合并那些由同一种单细胞 RNA 测序技术产生的批次。

通常鼓励通过找寻拥有更多共同群体的相似批次来找寻正确的 MNN 对——但这个合并策略对此加以限制。
相比之下，先进行较难的合并更可能将截然不同的亚群放到一起，从而引入错误。
因为初始合并是后续合并的参考，所以这样也将错误传递给后续步骤。

### 构建输入

分层合并可以通过在逐步合并批次中多次调用 `fastMNN()` 实现。
如果我们想要在根据批次合并之前移除每个批次内的 `Donor` 效应，
我们会根据供者拆分 GSE85241 中的数据，为每个供者创建一个 `SingleCellExperiment` 对象。

```{r}
all.donors <- unique(rescaled.gse85241$Donor)
table(rescaled.gse85241$Donor)
by.donor.85241 <- vector("list", length(all.donors))
names(by.donor.85241) <- sort(all.donors)
for (x in all.donors) {
    by.donor.85241[[x]] <- rescaled.gse85241[,rescaled.gse85241$Donor==x]
}
```

对 GSE81076 重复该过程。
为便于说明，将一些供者聚集在一起以确保在每个水平上检测 MNN 时都有足够的细胞。

```{r}
adj.donors <- c(D101="A", D102="A", D10631="A",
    D17="B", D1713="B", D172444="B",
    D2="C", D3="C",
    D71="D", D72="D", D73="D", D74="D")[rescaled.gse81076$Donor]
table(adj.donors)

all.donors <- unique(adj.donors)
by.donor.81076 <- vector("list", length(all.donors))
names(by.donor.81076) <- sort(all.donors)
for (x in all.donors) {
    by.donor.81076[[x]] <- rescaled.gse81076[,adj.donors==x]
}
```

使用 `multiBatchPCA()` 函数对 _所有_ 要合并的批次执行主成分分析。
因为显然不可能单独对每一个批次执行主成分分析, 这样就确保所有细胞位于同一坐标空间中。
需要强调， `multiBatchPCA()` 执行的是改进版主成分分析，确保每个矩阵在定义主成分空间时贡献相同。
这样避免了批次中细胞数不同带来的不平衡问题，小批次（可能只有单一细胞类型）不会被忽略。

```{r}
all.batches <- c(by.donor.85241, by.donor.81076)

# Cosine normalizing for consistency with fastMNN() defaults.
all.logcounts <- lapply(all.batches, logcounts)
scaled <- lapply(all.logcounts, batchelor::cosineNorm) 

set.seed(1000) # for irlba.
pc.all <- do.call(batchelor::multiBatchPCA, c(scaled, 
    list(d=50, BSPARAM=IrlbaParam(deferred=TRUE))
))
names(pc.all)
```

**来自Aaron的评论：**

- 为了方便，这里在批次水平输入上运用了 `multiBatchPCA()`。
也可以提供供者水平矩阵来平衡各供者的贡献。
- 我们先运行了 `multiBatchNorm()` 产生 `rescaled.gse*` 对象。
因此，余弦归一化在技术上不是必须的，因为所有批次应该都已经在同一标度下（详见 `?cosineNorm`）。
虽然如此，这里我们为了保持一致性仍然进行了余弦归一化，因为之前 `fasrMNN()` 已经默认开启余弦归一化。

### 进行逐步合并

将 GSE85241 中供者对应矩阵传给 `fastMNN()`, 设置 `pc.input=TRUE` 表明已进行降维操作。 
这里采用第一个供者作为参考空间^[如有需要可以通过 `auto.order=` 更改顺序]， 然后将其他供者细胞与第一个合并。
通过这种方式移除 GSE85241 批次中的供者效应。

```{r}
pcs.85241 <- pc.all[seq_along(by.donor.85241)]
mnn.out.85241 <- do.call(batchelor::fastMNN, c(pcs.85241, list(pc.input=TRUE)))
Rle(mnn.out.85241$batch)
```

注意当 `pc.input=TRUE` 时, 返回 `DataFrame` 而不是 `SingleCellExperiment`。
这反映提供主成分而非基因表达矩阵时，基因身份也随之丢失^[可以通过旋转向量重建，见下文]。
对 GSE81076 批次供者进行同样的操作。

```{r}
pcs.81076 <- tail(pc.all, length(by.donor.81076))
mnn.out.81076 <- do.call(batchelor::fastMNN, c(pcs.81076, list(pc.input=TRUE)))
Rle(mnn.out.81076$batch)
```

下一步是合并两个批次。
对已进行供者校正的两个批次再次调用 `fastMMN()`。
设置 `pc.input=TRUE` 以免函数在已校正数据上进行不必要（且错误）的余弦归一化和主成分分析。
最后一次调用 `fastMNN()` 时，采用更大 `k` 值提升对每个类群边界上异常值细胞检测 MNN 的鲁棒性。

```{r}
mnn.out3 <- batchelor::fastMNN(
    GSE81076=mnn.out.81076,
    GSE85241=mnn.out.85241, 
    pc.input=TRUE, k=100 # see comments below.
) 

Rle(mnn.out3$batch) # by dataset
Rle(c(mnn.out.81076$batch, mnn.out.85241$batch)) # by donor
```

最终得到一个批次内部供者效应和批次效应均被校正的表达矩阵。
通过 t-SNE 图检查每一步合并质量 (图 \@ref(fig:tsne-hmerge))。
每个批次内，供者充分混合，最终合并结果与图 \@ref(fig:tsne-batch) 一致。

```{r tsne-hmerge, fig.width=10, fig.asp=0.5, fig.cap="t-SNE plots after correcting for donor effects within each data set, and after correcting for batch effects between data sets (final). Each point represents a cell that is coloured according to its donor of origin (left, middle) or the data set of origin (right)."}
set.seed(1000)
par(mfrow=c(1,3))

library(Rtsne)
tout.85241 <- Rtsne(mnn.out.85241$corrected, pca=FALSE)
plot(tout.85241$Y[,1], tout.85241$Y[,2], main="GSE85241 donors",
    col=as.factor(mnn.out.85241$batch), xlab="tSNE1", ylab="tSNE2")

tout.81076 <- Rtsne(mnn.out.81076$corrected, pca=FALSE)
plot(tout.81076$Y[,1], tout.81076$Y[,2], main="GSE81076 donors",
    col=as.factor(mnn.out.81076$batch), xlab="tSNE1", ylab="tSNE2")

tout.all <- Rtsne(mnn.out3$corrected, pca=FALSE)
plot(tout.all$Y[,1], tout.all$Y[,2], main="Final",
    col=as.factor(mnn.out3$batch), xlab="tSNE1", ylab="tSNE2")
```

**来自 Aaron 的评论：**

- 为了方便，这里对批次层级输入运用了 `multiBatchPCA()`。
也可以提供供者水平矩阵来平衡各供者的贡献。
- 可能有人会问为什么在图 \@ref(fig:tsne-batch) 中也需要较大 `k` 值。
因为在没有移除供者效应时作 t-SNE 图，异常值可能会被供者间异质性掩盖。
- 在这个特定例子中，`mnn.out3$corrected` 矩阵中来自同一供者的细胞位于连续行。
不过，在每个 `SingleCellExperiment` 中原始细胞排序可能不是这样。
将最后的校正矩阵和原先顺序匹配起来需要一些额外记录。

   ```{r}
    original.plate <- unlist(lapply(rescaled, "[[", i="Plate"))
    original.names <- unlist(lapply(rescaled, colnames))
    
    # Needs unique names: trigger error otherwise.
    stopifnot(anyDuplicated(original.names)==0L)

    m <- match(rownames(mnn.out3$corrected), original.names)
    new.plate <- original.plate[m]
    ```

```{r, echo=FALSE, results="hide"}
gc()
```

## 自动指定

在不知道每个批次性质的情况下，用户可以设定 `auto.order=TRUE` 让 `fastMNN()` 根据经验选择每一步合并的批次。
第一次合并发生在具有最多 MNN 对的批次对中。
接下来的合并发生在和目前参考批次具有最多 MNN 对的批次。
目的是在每一步最大化 MNN 对数目，提供稳定校正。
我们通过 GSE81076 数据组中供者内亚批次来详细解释。

```{r}
mnn.out.auto <- do.call(batchelor::fastMNN, c(pcs.81076, 
    list(pc.input=TRUE, auto.order=TRUE)))
names(by.donor.81076) # supplied order 
metadata(mnn.out.auto)$merge.order # automatically defined order
```

手动指定时，合并顺序不会影响到输出的细胞顺序。
所以可以方便地尝试不同的合并顺序，不用考虑给输出细胞重新排序。

```{r}
Rle(mnn.out.auto$batch) 
```

自动合并需要消耗大量计算时间。
近邻搜索需要在所有批次对之间进行，然后一步步将剩下的批次与参考批次合并。
正是这样，我们更喜欢手工定义合并顺序，而且这样能更好地利用关于实验设计的先验知识。

```{r, echo=FALSE, results="hide"}
gc()
```

# 在后续分析中使用校正值

## 基于细胞分析

低维校正值可以用在任何包括计算和比较细胞（欧几里得）距离的步骤上。
批次校正的目的是将不同批次中关联细胞集合起来，但仍保留每个批次内细胞的生物差异。
目前还不能解释校正坐标的精确值，但是如果我们是对距离的相对值感兴趣，这就不是什么大问题。
例如，下面的代码在聚类时直接使用了 MNN 校正值。

```{r}
snn.gr <- buildSNNGraph(sce, use.dimred="corrected")
clusters <- igraph::cluster_walktrap(snn.gr)
table(clusters$membership, sce$batch)
```

图 \@ref(fig:tsne-cluster) 展示了 _t_-SNE 空间中类群标注和分离的强对应关系。

```{r tsne-cluster, fig.cap="t-SNE plot after MMN correction, where each point represents a cell and is coloured by its cluster identity."}
sce$Cluster <- factor(clusters$membership)
plotTSNE(sce, colour_by="Cluster")
```

校正值可以用在任何对细胞距离进行操作的步骤中。
包括近邻搜索，非线性可视化如 _t_-SNE和轨迹推理。

## 基于基因分析

对于基于基因的步骤如差异表达分析或是基因网络构建，应采用**原始**对数表达量或计数。
校正值不仅仅用于获取细胞水平的信息如聚类或是轨迹。
批次效应是通过批次间的元分析，利用区组术语来处理的。
不在基于基因分析中使用校正值，有这些原因：

- 由于无法模拟出校正的不确定性，通常用批次校正值来做差异表达分析不合适。
这会导致第一类错误出现，例如比预期更多的假阳性。
- 校正无法保留均值-方差关系。
使用常见差异表达方法如`r Biocpkg("edgeR")` 或 `r Biocpkg("limma")` 无效。
- 批次校正可能在将细胞投影到常见坐标系的过程中（正确地）移除了批次间生物差异。
回到未校正表达量，如果它们的确有趣，就给我们提供了一个发现差异的机会。
相反，如果批次校正出错，使用未校正表达量相当于做了一个可用性测试。

实际上，在这个 `fasttMNN()` 的特定例子中，批次校正值已经不再和每个基因的表达量对应。
这说明校正值不可以直接用于基于基因的分析^[但是有方法可以避免，见下文]。

在可以获取批次内替代品时，用户应当尽量避免使用批次校正数据进行基因分析。
我们使用先前聚类结果在未校正表达数据上进行差异表达分析来说明。
为了模拟批次效应，将 `findMarkers()` 批次来源设置为 `block=`。
这样它会比较批次内所有类群，结合 $p$ -值来加强批次间的结果。

```{r}
m.out <- findMarkers(sce, clusters$membership, block=sce$batch,
    direction="up", assay.type="original")
demo <- m.out[["10"]] # probably alpha cells.
demo <- demo[demo$Top <= 5,]
as.data.frame(demo[,1:3]) # only first three columns for brevity.
```

```{r, echo=FALSE, results="hide"}
# Checking that cluster 10 is what we think it is.
stopifnot(all(sapply(demo["GCG",-(1:3)], sign)==1))
```

其他关于在定义标志基因时如何处理批次效应的方法参考 `r simpleSingleCell:::.link("de", "Blocking on uninteresting factors of variation", "elsewhere")` 中的讨论。
与用标准 Bioconductor 包如 `r Biocpkg("edgeR")` 或 `r Biocpkg("limma")` 进行差异表达分析类似。
使用 `block=` 类似于使用批次-聚类互作模型并测试批次间的平均对数倍数差是否为 0。

**来自 Aaron 的评论**

- 使用老版 `mnCorrect()` 函数的用户会发先它返回的是校正表达量。
直接使用这些校正值进行差异表达分析或许很诱人，但并不合适。
除了上面说的原因之外，使用默认参数的 `mnnCorrect()` 返回的校正值不是对数尺度而是余弦归一化对数尺度。
这对于基于校正值的差异分析来说，很难解释效应量。

## 获取每个基因的校正值

将 `fastMNN()` 用于基因表达量时也返回一个矩阵，矩阵元素为 `reconstructed` 谱里的校正基因表达量。
这个矩阵通过低维校正值和初始 PCA 中的旋转向量叉乘得到，
有效逆转了开始时在 `multiBatchPCA()` 中向低维空间的投影。
下面的例子为提取胰岛素的校正表达量。

```{r}
assay(sce, "reconstructed")
summary(assay(sce)["INS",])
```

如果 `fastMNN()` 的输入为低维数据，那么也只会输出低维数据。
尽管如此，用户还是可以通过 PCA 旋转向量手动计算叉乘来获得基因校正值。
例如下面的代码，从分层合并中获取了 _GCG_ 的校正表达量。

```{r}
rotations <- metadata(pc.all)$rotation
cor.exp <- tcrossprod(mnn.out3$corrected,
    rotations["ENSG00000115263",,drop=FALSE])
summary(cor.exp)
```

对所有基因校正值进行显示计算不太明智，因为这可能会构建出一个稠密矩阵。
这对于用稀疏矩阵表示的大型数据集来说非常消耗内存。
当然，如有需要，可以对特定基因计算校正值，例如使用 `LowRankMatrix` 类。

基因校正值可以用在可视化上，如图 \@ref(fig:tsne-markers)。
它比未校正值更美观，不同批次细胞的未校正值可能会有更大的色度偏移。
但是，在任何量化步骤中采用校正值都需要十分谨慎。
如果必须要用，需要有在未校正值上相似的分析结果作为支撑。

# 结语

我们保存了 `SingleCellExperiment` 对象以随时使用。
避免上述步骤存在多余重复。

此工作流程中所有软件包都可以在 Comprehensive R Archive Network (https://cran.r-project.org) 或 Bioconductor project (http://bioconductor.org) 获取。
包的版本号及对应R版本如下所示。

```{r}
sessionInfo()
```

# 参考文献

