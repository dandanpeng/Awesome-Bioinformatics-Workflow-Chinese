---
title: 检测单细胞 RNA 测序数据中的双细胞
author:
- name: Aaron T. L. Lun
  affiliation: &CRUK Cancer Research UK Cambridge Institute, Li Ka Shing Centre, Robinson Way, Cambridge CB2 0RE, United Kingdom
date: "`r Sys.Date()`"
vignette: >
  %\VignetteIndexEntry{08. Detecting doublets}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
output:
  BiocStyle::html_document:
    titlecaps: false
    toc_float: true
bibliography: ref.bib
---

```{r style, echo=FALSE, results='hide', message=FALSE, cache=FALSE}
library(BiocStyle)
library(knitr)
opts_chunk$set(error=FALSE, message=FALSE, warning=FALSE, cache=TRUE)
opts_chunk$set(fig.asp=1)
```

# 综述

在单细胞 RNA 测序（scRNA-seq）实验中，双细胞是两个细胞产生的人工文库。
它们的产生主要是因为细胞排序或捕获中出现错误，特别是包含上千个细胞的基于液滴实验方案 [@zheng2017massively]。
当目标为在 __单__ 细胞水平上进行群体表征，很明显双细胞会引发问题。
尤其是它们可能会错误地暗示实际上并不存在的中间群体或临时状态存在。
因此最好移除双细胞文库，这样它们就不会影响结果解释。

目前有几个实验策略用于双细胞移除。
一个方法是通过多个捐赠者池化细胞时利用自然遗传变异 [@kang2018multiplexed]。
双细胞可以被当作是不存在于任何单个捐献者体内的等位基因组合文库。
另一个方法是用与其他寡核苷酸偶联的抗体来标记一部分细胞（例如来自同一样本的所有细胞）[@stoeckius2017hashing]。
池化时，我们认为含有不同寡核苷酸的文库是双细胞，需要去除。
这些方法很有效，但是依赖于一些不便获取的实验信息。

更广泛使用的方法是仅根据表达谱推测双细胞 [@dahlin2018single]。
在此工作流程中，我们会提供两种从单细胞 RNA 测序数据中发现双细胞的纯计算方法。
这两种方法的主要区别在于事先是否需要聚类信息。
它们均在开源 Bioconductor 项目中的 `r Biocpkg("scran")` 包内实现 [@huber2015orchestrating]。
下面将通过基于液滴单细胞 RNA 测序研究小鼠乳腺的数据 [@bach2017differentiation] 来说明这两种方法的使用，
数据可通过 NCBI GEO 登录号 GSE106273 获取。

```{r}
library(BiocFileCache)
bfc <- BiocFileCache("raw_data", ask = FALSE)
base.path <- "ftp://ftp.ncbi.nlm.nih.gov/geo/samples/GSM2834nnn/GSM2834500/suppl"
barcode.fname <- bfcrpath(bfc, file.path(base.path, 
    "GSM2834500%5FG%5F1%5Fbarcodes%2Etsv%2Egz"))
gene.fname <- bfcrpath(bfc, file.path(base.path,
    "GSM2834500%5FG%5F1%5Fgenes%2Etsv%2Egz"))
counts.fname <- bfcrpath(bfc, file.path(base.path,
    "GSM2834500%5FG%5F1%5Fmatrix%2Emtx%2Egz"))
```

# 准备数据

## 读入计数

通过计数矩阵构建一个 `SingleCellExperiment` 对象。
这个文件通过修改 _CellRanger_ 输出得到，所以需要手动加载而不能使用 `read10xCounts()`。

```{r}
library(scater)
library(Matrix)
gene.info <- read.table(gene.fname, stringsAsFactors=FALSE)
colnames(gene.info) <- c("Ensembl", "Symbol")
sce <- SingleCellExperiment(
    list(counts=as(readMM(counts.fname), "dgCMatrix")), 
    rowData=gene.info, 
    colData=DataFrame(Barcode=readLines(barcode.fname))
)
```

将更有意义的信息放在行名与列名中。
使用 `uniquifyFeatureNames()` 可以从 gene symbol 中生成特定行名。

```{r}
rownames(sce) <- uniquifyFeatureNames(
    rowData(sce)$Ensembl, rowData(sce)$Symbol)
colnames(sce) <- sce$Barcode
sce
```

加入一些基因组定位注释以便下游分析。

```{r}
library(TxDb.Mmusculus.UCSC.mm10.ensGene)
chrloc <- mapIds(TxDb.Mmusculus.UCSC.mm10.ensGene, keytype="GENEID", 
    keys=rowData(sce)$Ensembl, column="CDSCHROM")
rowData(sce)$Chr <- chrloc
```

## 质量控制

通过 `r Biocpkg("scater")` 包 [@mccarthy2017scater] 中的 `calculateQCMetrics()` 函数计算质量控制指标。

```{r}
is.mito <- rowData(sce)$Chr == "chrM"
summary(is.mito)
sce <- calculateQCMetrics(sce, feature_controls=list(Mito=which(is.mito)))
```

如之前所述，移除了所有指标中的异常值细胞。
注意原研究作者已经执行了一些质量控制手段，所以这里丢弃的细胞相对较少。

```{r}
low.lib <- isOutlier(sce$total_counts, log=TRUE, nmads=3, type="lower")
low.nexprs <- isOutlier(sce$total_features_by_counts, log=TRUE, nmads=3, type="lower")
high.mito <- isOutlier(sce$pct_counts_Mito, nmads=3, type="higher")
discard <- low.lib | low.nexprs | high.mito
DataFrame(LowLib=sum(low.lib), LowNum=sum(low.nexprs), HighMito=sum(high.mito), 
    Discard=sum(discard), Kept=sum(!discard))
```

对 `SingleCellExperiment` 对象取子集以移除低质量细胞。

```{r}
sce <- sce[,!discard]
```

## 归一化细胞特异性变差

在预聚类时使用去卷积方法计算用于缩放归一化细胞特异性偏差的量化因子。

```{r}
library(scran)
library(BiocSingular)
set.seed(1000)
clusters <- quickCluster(sce, use.ranks=FALSE, BSPARAM=IrlbaParam())
table(clusters)
sce <- computeSumFactors(sce, clusters=clusters, min.mean=0.1) 
summary(sizeFactors(sce))
```

然后计算归一化对数表达量以便下游使用。
此数据集不包含 spike-in 转录本，所以无需使用 `computeSpikeFactors()` 进行单独归一化。

```{r}
sce <- normalize(sce)
assayNames(sce)
```

## 模拟并去除噪音

因为我们没有 spike-in，所以这里使用 `makeTechTrend()` 函数来模拟技术噪音。

```{r varplot, fig.cap="Variance of the log-expression values as a function of the mean log-expression in the mammary gland data set. Each point represents a gene, and the red line corresponds to Poisson variance."}
tech.trend <- makeTechTrend(x=sce)
fit <- trendVar(sce, use.spikes=FALSE)
plot(fit$mean, fit$var, pch=16, 
    xlab="Mean log-expression",
    ylab="Variance of log-expression")
curve(tech.trend(x), add=TRUE, col="red")
```

基于每个基因的技术噪音，使用 `denoisePCA()` 选择保留主成分个数。
由于使用了 `r Biocpkg("irlba")` 中的随机方法，当 `BSPARAM=IrlbaParam()` 时，需要设置种子以便重复。

```{r}
set.seed(12345)
sce <- denoisePCA(sce, technical=tech.trend, BSPARAM=IrlbaParam())
ncol(reducedDim(sce))
```

## 聚类为亚群

使用 `buildSNNGraph()` [@xu2015identification] 将细胞聚类为假定亚群。
使用更高的 `k` 值提高聚类的连通性，降低粒度。

```{r}
snn.gr <- buildSNNGraph(sce, use.dimred="PCA", k=25)
sce$Cluster <- factor(igraph::cluster_walktrap(snn.gr)$membership)
table(sce$Cluster)
```

在 _t_-SNE 图中可视化聚类结果 [@van2008visualizing]。
图 \@ref(fig:tsneclust) 表明有一些间隔清晰的类，也有一些相互联系的类。

```{r tsneclust, fig.cap="t-SNE plot of the mammary gland data set. Each point is a cell coloured according to its assigned cluster identity."}
set.seed(1000)
sce <- runTSNE(sce, use_dimred="PCA")
plotTSNE(sce, colour_by="Cluster")
```

## 通过聚类发现双细胞

`doubletCluster()` 函数会识别具有其他两个类群中间表达谱的类群 [@bach2017differentiation]。
也就是说，它会检查每三个类：包括一个查询类和它的两个父类。
然后计算得到一些统计量：

- 查聚类和两个父类 _都_ 进行比较，得到在相同方向差异表达的基因数目（`N`）。
这些基因将会是查询类的特有标记，并为零假设提供证据，例如查询类含有来自两个父类的双细胞。
含有极少特有基因的类群更有可能是双细胞。
- 每个父类样本中文库大小的中位数与查询聚类中文库大小的中位数的比值（`lib.size*`）。
双细胞文库产生自一个与单细胞相比更大的 RNA 初始池，因此前者的文库应当更大。
文库大小比值远大于总量的情况与查询类的双细胞身份不符。
- 查询类中的细胞占比也应该是合理的 —— 一般少于所有细胞的 5%，取决于有多少细胞装载到 10X 基因组设备上。

```{r}
dbl.out <- doubletCluster(sce, sce$Cluster)
dbl.out
```

```{r, echo=FALSE, results="hide"}
# Hidden variables for use in text or hidden chunks,
# to avoid the need for manual changes.
chosen.doublet <- 7
```

对 `doubletCluster()` 输出结果的检查表明，类 `r chosen.doublet` 的特有基因最少而文库大小近似或大于父类。
可以看到这个类中检测出的每个基因都在两个拟定父类之一中表达（图 \@ref(fig:heatclust)）。

```{r heatclust, fig.cap=sprintf("Heatmap of mean-centred and normalized log-expression values for the top set of markers for cluster %i in the mammary gland dataset. Column colours represent the cluster to which each cell is assigned, as indicated by the legend.", chosen.doublet)}
markers <- findMarkers(sce, sce$Cluster, direction="up")
dbl.markers <- markers[["7"]]
chosen <- rownames(dbl.markers)[dbl.markers$Top <= 10]
plotHeatmap(sce, columns=order(sce$Cluster), colour_columns_by="Cluster", 
    features=chosen, cluster_cols=FALSE, center=TRUE, symmetric=TRUE, 
    zlim=c(-5, 5), show_colnames=FALSE)
```

```{r, echo=FALSE, results="hide"}
# Checking that we've picked the correct cluster.
acta2 <- sapply(dbl.markers["Acta2", -(1:3)], sign)
csn2 <- sapply(dbl.markers["Csn2", -(1:3)], sign)

below <- acta2 < 0
stopifnot(all(csn2[below] == 1))
below <- csn2 < 0
stopifnot(all(acta2[below] == 1))
```

对一些已知标记基因进行进一步检查，发现该类包含基底细胞（_Acta2_）和肺泡细胞（_Csn2_）的双细胞（图 \@ref(fig:markerexprs)）。
实际上，并没有已知细胞类型同时高表达这些基因，也支持该类仅包含双细胞的假设^[尽管出现双细胞是对该类表达谱更严谨的解释，当然也有可能是它代表一个全新的细胞类型，]。

```{r markerexprs, fig.asp=0.5, fig.width=10, fig.cap="Distribution of log-normalized expression values for _Acta2_ and _Csn2_ in each cluster. Each point represents a cell."}
plotExpression(sce, features=c("Acta2", "Csn2"), 
    x="Cluster", colour_by="Cluster")
```

`doubletCluster()` 的强项在于简洁和易于解释。
基于这个函数返回的指标，可以对存疑类快速标记以便进一步调查。
但很显然它依赖于聚类质量。
过于粗糙的聚类可能无法将双细胞与其它细胞区分开来，但过于精细的聚类又会让解释变复杂。

**来自 Aaron 的评论：**

- `doubletClusters()` 输出应该被看作是具有优先级的「高风险」类，需要更细致的调查。
我们不推荐在识别双细胞类时对所有指标设置固定阈值。
指标的合适阈值取决于聚类质量和生物学背景。
- 每个查询类的那对父类都是基于最低 `N` 值单独识别出。
这说明不是任何高于 unity 的 `lib.size*` 都能作为查询类是双细胞的确凿证据。
可能是「真正的」父类紧邻检测到的父类，但是 `N` 值略高。
如果发生这种情况，查看 `all.pairs` 域中给定查询类所有可能父类对的统计量。
- 具有少量细胞的类更有可能被识别为双细胞。
这是因为在它们中发现差异表达基因的可能性更小，因此 `N` 值很可能较小。
幸运的是，这一影响对我们来说是好事，因为在正确操作的单细胞 RNA 测序实验中，双细胞本就应该很稀少。

# 通过模拟检测双细胞

## 背景

另一个检测双细胞的策略是根据单细胞表达谱 _计算机_ 模拟双细胞 [@dahlin2018single]。
通过 `r Biocpkg("scran")` 中的 `doubletCells()` 函数可以：

1. 加入两个随机选择的单细胞表达谱模拟上千个双细胞。
2. 对每个初始细胞计算周边环境中模拟双细胞的密度。
3. 对每个初始细胞计算周围邻居中可观测细胞的密度。
4. 返回两个密度的比值作为每个细胞的「双细胞分数」。

这个方法假设模拟双细胞和真是双细胞十分类似。
使用随机选择可以解释不同亚群的相对丰度，它影响了亚群介入双细胞的可能性；
计算比值避免了高丰度亚群中的非双细胞细胞获得高分。
接下来运行这个函数：

```{r}
set.seed(100)
dbl.dens <- doubletCells(sce, BSPARAM=IrlbaParam())
summary(dbl.dens)
```

得分最高的双细胞聚集在单个细胞类中，位于图 \@ref(fig:denstsne) 中央。

```{r denstsne, fig.cap="t-SNE plot of the mammary gland data set. Each point is a cell coloured according to its doublet density."}
sce$DoubletScore <- dbl.dens
plotTSNE(sce, colour_by="DoubletScore")
```

根据聚类信息，我们可以看到受影响的细胞属于同一类，即由 `doubletCluster()` 识别出的类（图 \@ref(fig:densclust)）。

```{r densclust, fig.cap="Distribution of doublet scores for each cluster in the mammary gland data set. Each point is a cell."}
plotColData(sce, x="Cluster", y="DoubletScore", colour_by="Cluster")
```

**来自 Aaron 的评论：**

- 为加速密度计算，`doubletCells()` 对对数表达矩阵执行了主成分分析。
当 `BSPARAM=IrlbaParam()` 时，`r CRANpkg("irlba")` 包会执行快速近似主成分分析。
这里包含随即项，需要调用 `set.seed()` 以确保结果可重复。

## 优点与缺点

`doubletCells()` 的优点是不依赖聚类，降低了结果对聚类质量的敏感度。
缺点是对于双细胞的形成需要强有力的假设，例如合并比例和采样自纯亚群。
尤其是 `doubletCells()` 将每个细胞的文库大小视作它们总 RNA 含量的精确替代值。
如果这里出错的话，模拟时也会以错误的比例结合不同细胞的表达谱。
意味着模拟双细胞会系统地从真实双细胞偏离，导致后者的双细胞得分过低。

简单地将双细胞分数高的细胞移除不足以从数据集中清除真正的双细胞。
如图 \@ref(fig:densclust) 所示，只有一部分被认定为双细胞类中的细胞具有高分。
移除掉这些还是会给那一类遗留下足够的细胞误导下游分析。
实际上，因为对于分数的解释是相对的，所以很难给双细胞分数定义一个阈值。
对于文库大小要超过多少时才可以被认为是双细胞并没有一个一般性定义。

我们建议根据类群注释来解释 `doubletCells()` 得分。
双细胞分数平均值高的类群中的所有细胞都有嫌疑。
出现问题的类群 （例如被 `clusterModularity()` 识别出，详见 `r simpleSingleCell:::.link("umis", "Evaluating graph-based clusters", "here")`）应当谨慎对待。
仅含一小部分高分细胞的类群可以参与下游分析，前提是用户已经调查确认它们没有被这些高分细胞驱动^[例如，检查一个感兴趣的基因的差异表达不仅仅由双细胞高分细胞驱动。]。
尽管聚类仍然需要，这个方法在聚类质量上优于`doubletClusters()`。

**来自 Aaron 的评论：**

- 有些情况下，调用 `doubletCells()` 时设置 `force.match=TRUE` 可以让结果更明晰。
这个参数强制匹配每个模拟双细胞与原始数据集中的近邻细胞。
如果模拟双细胞与真实双细胞之间足够近，可以正确得识别出近邻，那么二者之间的任何系统差异都会被移除。
这解决了一些与 RNA 含量相关的问题，但也是一个激进策略，可能会错误地夸大报告双细胞得分。
- 如果可以获取 spike-in 信息，例如采用基于平板的实验方案，那么结合比例未知的问题完全可以解决。
这会给每个细胞的总 RNA 含量提供一个准确估计。
为此，`computeSpikeFactors()` 中的量化因子（见`r simpleSingleCell:::.link("spike", NULL, label="here")`）可以通过参数 `size.factors.content=` 提供给函数 `doubletCells()`。
它会通过 spike-in 量化因子按比计算每个细胞对双细胞文库的贡献。

# 结语

双细胞检测步骤只适用于同一实验批次产生的文库。
显然双细胞不会在两个被单独捕获的细胞间形成。
因此，在使用上述函数前需要对实验设计有一些基本理解，
以免对不可能包含双细胞的类群的合理性产生不必要担忧。

对于包含细胞轨迹的数据，很难去解释双细胞预测结果。
根据定义，位于轨迹中点的细胞一定是两个细胞中间体，容易被误认为是双细胞。
许多真实轨迹的非线性特性提供了保护作用，降低了模拟双细胞与 `doubletCells()` 中真实细胞一致的风险。
在连续的生物过程中不太可能突然有 RNA 加入的假设下，
大家也可以多注意 `doubletCluster()` 中相对文库大小而不是只关注 `N` 值。

解决双细胞问题的最好方案是实验 —— 在一开始避免它们产生。
在设计单细胞 RNA 测序实验时就应当考虑好，在以最低成本获得大量细胞和双细胞变多会破坏数据质量与可靠性之间做好权衡^[但我们希望不那么抠门的课题负责人都能理解。]。
其他实验方法利用样本特异细胞「标签」识别多重实验中的双细胞 [@kang2018multiplexed;@stoekius2018hashing]。
如果可以获取这些信息，建议利用它们标记可能的双细胞类群而不是简单地将其直接移除，
因为后者不会移除标记相同的细胞组成的双细胞。

保存 `SingleCellExperiment` 对象和相关数据以便后续使用。

```{r}
saveRDS(sce, file="mammary_data.rds")
```

此工作流程中的所有软件包都可以在 Comprehensive R Archive Network (https://cran.r-project.org) 或 Bioconductor project (http://bioconductor.org) 获取。
包的版本号及对应的R版本如下所示。

```{r}
sessionInfo()
```

# 参考文献
